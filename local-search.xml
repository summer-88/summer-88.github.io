<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo添加支持emoji</title>
    <link href="/2021/12/02/hexo%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81emoji/"/>
    <url>/2021/12/02/hexo%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81emoji/</url>
    
    <content type="html"><![CDATA[<h1>hexo添加支持emoji</h1><p><u><strong>很简单，换一个 markdown 引擎，然后再增加 emoji 插件即可。</strong></u></p><hr><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm un hexo-renderer-marked --save</span><span class="hljs-meta">$</span><span class="bash"> npm i hexo-renderer-markdown-it --save</span> <span class="hljs-meta">$</span><span class="bash"> npm install markdown-it-emoji --save</span></code></pre></div><p><u><strong>然后编辑 _config.yml：</strong></u></p>  <div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">markdown:</span><span class="hljs-attr">preset:</span> <span class="hljs-string">&#x27;default&#x27;</span><span class="hljs-attr">render:</span>  <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">langPrefix:</span> <span class="hljs-string">&#x27;language-&#x27;</span>  <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">quotes:</span> <span class="hljs-string">&#x27;“”‘’&#x27;</span><span class="hljs-attr">enable_rules:</span><span class="hljs-attr">disable_rules:</span><span class="hljs-attr">plugins:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span><span class="hljs-attr">anchors:</span>  <span class="hljs-attr">level:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">&#x27;header-anchor&#x27;</span>  <span class="hljs-attr">permalinkSide:</span> <span class="hljs-string">&#x27;left&#x27;</span>  <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">&#x27;¶&#x27;</span>  <span class="hljs-attr">case:</span> <span class="hljs-number">0</span>  <span class="hljs-attr">separator:</span> <span class="hljs-string">&#x27;-&#x27;</span></code></pre></div><p>使用方法在<a href="https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-1">Emoji</a> 中找到你想要的表情，然后点击即可复制。<br>比如你想发一个笑脸 😄 直接输入笑脸对应的 emoji 编码就可以。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WSL常用命令</title>
    <link href="/2021/12/01/WSL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/12/01/WSL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1>WSL常用命令</h1><h3 id="查看所有已经安装的分发版本：">查看所有已经安装的分发版本：</h3><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">wsl</span> --<span class="hljs-comment">list</span> --<span class="hljs-comment">all</span></code></pre></div><h3 id="查看正在运行的分发版本：">查看正在运行的分发版本：</h3><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">wsl</span> --<span class="hljs-comment">list</span> --<span class="hljs-comment">running</span></code></pre></div><h3 id="删除指定的分发版本：">删除指定的分发版本：</h3><div class="hljs code-wrapper"><pre><code class="hljs ada">wsl <span class="hljs-comment">--unregister &lt;DistributionName&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java获取常见的系统信息</title>
    <link href="/2021/11/30/Java%E8%8E%B7%E5%8F%96%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
    <url>/2021/11/30/Java%E8%8E%B7%E5%8F%96%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1>Java获取常见的系统信息</h1><p>😂</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 文件路径分隔符</span>String fileSeparator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">File</span>.</span></span>separator;<span class="hljs-comment">// 用户主目录</span>String userHome = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Properties()</span>.get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;user.home&quot;</span>)</span>;<span class="hljs-comment">// Java的jre的安装路径</span>String javaPath = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Properties()</span>.get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;java.home&quot;</span>)</span>;<span class="hljs-comment">// 操作系统名称</span>String osName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Properties()</span>.get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;os.name&quot;</span>)</span>;<span class="hljs-comment">// 当前用户程序所在目录</span>String userDir = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Properties()</span>.get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;user.dir&quot;</span>)</span>;<span class="hljs-comment">// JDK的安装目录</span>String jdkDir = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Properties()</span>.get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>)</span>;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信支付代码</title>
    <link href="/2021/11/29/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/11/29/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qujie.mintwo.system.wechatpay;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.qujie.mintwo.config.WechatConfig;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.Validator;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.auth.*;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.util.AesUtil;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.util.PemUtil;<span class="hljs-keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;<span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpUriRequest;<span class="hljs-keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;<span class="hljs-keyword">import</span> org.apache.http.util.EntityUtils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<span class="hljs-keyword">import</span> java.security.GeneralSecurityException;<span class="hljs-keyword">import</span> java.security.PrivateKey;<span class="hljs-keyword">import</span> java.security.cert.X509Certificate;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Comparator;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.apache.http.HttpHeaders.ACCEPT;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.apache.http.HttpHeaders.CONTENT_TYPE;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.apache.http.HttpStatus.SC_OK;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.apache.http.entity.ContentType.APPLICATION_JSON;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 夏天</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/11/24</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WechatPayApiUtil</span> </span>&#123;    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(WechatPayApiUtil.class);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 参数配置</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> WechatConfig wechatConfig;    <span class="hljs-function"><span class="hljs-keyword">public</span> CloseableHttpResponse <span class="hljs-title">v3Execution</span><span class="hljs-params">(HttpUriRequest request)</span> <span class="hljs-keyword">throws</span> IOException, GeneralSecurityException </span>&#123;        request.addHeader(CONTENT_TYPE, APPLICATION_JSON.toString());        request.addHeader(ACCEPT, APPLICATION_JSON.toString());        FileInputStream privateKey;        <span class="hljs-keyword">try</span> &#123;            privateKey = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\apiClient_key.pem&quot;</span>);        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;            logger.error(<span class="hljs-string">&quot;微信支付接口调用所需的私钥文件不存在,路径【&#123;&#125;】&quot;</span>,wechatConfig.getPrivateKeyPath());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;微信支付接口调用所需的私钥文件不存在&quot;</span>);        &#125;        PrivateKey merChantPrivateKey = PemUtil.loadPrivateKey(privateKey);        List&lt;X509Certificate&gt; certs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">try</span> &#123;            FileInputStream certKey = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\api\\apiClient_cert.pem&quot;</span>);            certs.add(PemUtil.loadCertificate(certKey));        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;            logger.error(<span class="hljs-string">&quot;微信支付接口调用所需的平台证书文件不存在,路径【&#123;&#125;】&quot;</span>,wechatConfig.getCertKeyPath());            certs = downloadCertificate();        &#125;        AutoUpdateCertificatesVerifier verifier = <span class="hljs-keyword">new</span> AutoUpdateCertificatesVerifier(                <span class="hljs-keyword">new</span> WechatPay2Credentials(wechatConfig.getMerchantId(), <span class="hljs-keyword">new</span> PrivateKeySigner(wechatConfig.getSerialNumber(), merChantPrivateKey)),                wechatConfig.getApiKey().getBytes(StandardCharsets.UTF_8));        WechatPayHttpClientBuilder builder = WechatPayHttpClientBuilder.create()                .withMerchant(wechatConfig.getMerchantId(),wechatConfig.getSerialNumber(),merChantPrivateKey).withValidator(<span class="hljs-keyword">new</span> WechatPay2Validator(verifier));        <span class="hljs-keyword">try</span> (CloseableHttpClient client = builder.build()) &#123;            CloseableHttpResponse response = client.execute(request);            <span class="hljs-keyword">int</span> statusCode = response.getStatusLine().getStatusCode();            String body = EntityUtils.toString(response.getEntity());            <span class="hljs-keyword">if</span> (SC_OK == statusCode) &#123;                logger.info(<span class="hljs-string">&quot;微信支付商家平台接口调用成功,接口响应信息：【&#123;&#125;】&quot;</span>,body);                <span class="hljs-keyword">if</span>(validate(response,certs))&#123;                    logger.info(<span class="hljs-string">&quot;微信支付商家平台响应信息验证签名成功&quot;</span>);                    <span class="hljs-keyword">return</span> response;                &#125;<span class="hljs-keyword">else</span> &#123;                    logger.error(<span class="hljs-string">&quot;微信支付商家平台响应信息验证签名失败&quot;</span>);                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;微信支付商家平台响应信息验证签名失败&quot;</span>);                &#125;            &#125;<span class="hljs-keyword">else</span> &#123;                logger.error(<span class="hljs-string">&quot;微信支付商家平台接口调用失败,错误码【&#123;&#125;】,错误信息【&#123;&#125;】&quot;</span>,statusCode,body);                <span class="hljs-keyword">return</span> response;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validate</span><span class="hljs-params">(CloseableHttpResponse response,List&lt;X509Certificate&gt; x509Certs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//从下载的证书中，获取对报文签名的私钥所对应的证书，并进行验签来验证证书准确</span>        Verifier verifier = <span class="hljs-keyword">new</span> CertificatesVerifier(x509Certs);        Validator validator = <span class="hljs-keyword">new</span> WechatPay2Validator(verifier);        <span class="hljs-keyword">return</span>  validator.validate(response);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;X509Certificate&gt; <span class="hljs-title">downloadCertificate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, GeneralSecurityException </span>&#123;        FileInputStream privateKey;        <span class="hljs-keyword">try</span> &#123;            privateKey = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\apiClient_key.pem&quot;</span>);        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;            logger.error(<span class="hljs-string">&quot;微信支付接口调用所需的私钥文件路径【&#123;&#125;】不存在&quot;</span>,wechatConfig.getPrivateKeyPath());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;微信支付接口调用所需的私钥文件不存在&quot;</span>);        &#125;        PrivateKey merChantPrivateKey = PemUtil.loadPrivateKey(privateKey);        WechatPayHttpClientBuilder builder = WechatPayHttpClientBuilder.create()                .withMerchant(wechatConfig.getMerchantId(),wechatConfig.getSerialNumber(),merChantPrivateKey).withValidator(response -&gt; <span class="hljs-keyword">true</span>);        HttpGet httpGet = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">&quot;https://api.mch.weixin.qq.com/v3/certificates&quot;</span>);        httpGet.addHeader(ACCEPT, APPLICATION_JSON.toString());        <span class="hljs-keyword">try</span> (CloseableHttpClient client = builder.build()) &#123;            CloseableHttpResponse response = client.execute(httpGet);            <span class="hljs-keyword">int</span> statusCode = response.getStatusLine().getStatusCode();            String body = EntityUtils.toString(response.getEntity());            <span class="hljs-keyword">if</span> (SC_OK != statusCode) &#123;                logger.error(<span class="hljs-string">&quot;微信支付商家平台接口调用失败,接口响应码：【&#123;&#125;】,接口响应信息：【&#123;&#125;】&quot;</span>,statusCode,body);                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;微信支付商家平台接口调用失败&quot;</span>);            &#125;            logger.info(<span class="hljs-string">&quot;微信支付平台证书获取成功,接口响应信息：【&#123;&#125;】&quot;</span>,body);            CertificateList certList = JSON.parseObject(body, CertificateList.class);            List&lt;X509Certificate&gt; x509Certs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            AesUtil aesUtil = <span class="hljs-keyword">new</span> AesUtil(wechatConfig.getApiKey().getBytes(StandardCharsets.UTF_8));            CertificateItem certificateItem = certList.getCerts().stream().max(Comparator.comparing(CertificateItem::getExpireTime)).orElse(<span class="hljs-keyword">null</span>);            <span class="hljs-keyword">if</span>(certificateItem == <span class="hljs-keyword">null</span>)&#123;                logger.error(<span class="hljs-string">&quot;微信支付获取平台证书接口响应信息获取证书为空&quot;</span>);                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;微信支付获取平台证书接口响应信息获取证书为空&quot;</span>);            &#125;            String plainCertificate = aesUtil.decryptToString(certificateItem.getEncryptCertificate().getAssociatedData().getBytes(StandardCharsets.UTF_8),                    certificateItem.getEncryptCertificate().getNonce().getBytes(StandardCharsets.UTF_8),                    certificateItem.getEncryptCertificate().getCiphertext());            ByteArrayInputStream inputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(plainCertificate.getBytes(StandardCharsets.UTF_8));            X509Certificate x509Cert = PemUtil.loadCertificate(inputStream);            x509Certs.add(x509Cert);            <span class="hljs-comment">//从下载的证书中，获取对报文签名的私钥所对应的证书，并进行验签来验证证书准确</span>            <span class="hljs-keyword">boolean</span> isCorrectCert = validate(response,x509Certs);            logger.info(isCorrectCert ? <span class="hljs-string">&quot;=== validate success ===&quot;</span> : <span class="hljs-string">&quot;=== validate failed ===&quot;</span>);            <span class="hljs-keyword">if</span>(!isCorrectCert)&#123;                logger.error(<span class="hljs-string">&quot;微信支付平台证书响应结果验证失败&quot;</span>);                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;微信支付平台证书响应结果验证失败&quot;</span>);            &#125;            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\api&quot;</span>);            <span class="hljs-keyword">if</span>(!file.exists())&#123;                <span class="hljs-keyword">boolean</span> result = file.mkdirs();                logger.info(<span class="hljs-string">&quot;目录【&#123;&#125;】不存在需要创建目录，创建结果：【&#123;&#125;】&quot;</span>,file.getAbsolutePath(),result);            &#125;            String outputAbsoluteFilename = file.getAbsolutePath() + File.separator + <span class="hljs-string">&quot;apiClient_cert.pem&quot;</span>;            <span class="hljs-keyword">try</span> (BufferedWriter writer = <span class="hljs-keyword">new</span> BufferedWriter(                    <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(outputAbsoluteFilename), StandardCharsets.UTF_8))) &#123;                writer.write(plainCertificate);            &#125;            logger.info(<span class="hljs-string">&quot;save cert file absolute path &#123;&#125; &quot;</span> , outputAbsoluteFilename);            <span class="hljs-keyword">return</span> x509Certs;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Postman汉化</title>
    <link href="/2021/11/22/Postman%E6%B1%89%E5%8C%96/"/>
    <url>/2021/11/22/Postman%E6%B1%89%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1>Postman汉化</h1><p>进入[Github下载页面](<a href="https://github.com/hlmd/Postman-cn/releases">Releases · hlmd/Postman-cn (github.com)</a>)<strong>下载对应版本的</strong> app.zip，<strong>进入</strong><code>Postman安装地址/版本/resources</code><strong>目录</strong>，</p><p>复制<code>app.zip</code>到<code>resources</code>目录，将<code>app.zip</code>解压到当前文件夹会生成一个<code>app</code>目录，重启Postman就可以了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7修改服务器名称</title>
    <link href="/2021/11/18/Centos7%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0/"/>
    <url>/2021/11/18/Centos7%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">yourhostname</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA容器</title>
    <link href="/2021/11/18/JAVA%E9%9B%86%E5%90%88/"/>
    <url>/2021/11/18/JAVA%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1>Java 容器</h1><!-- GFM-TOC --><ul><li><a href="#java-%E5%AE%B9%E5%99%A8">Java 容器</a><ul><li><a href="#%E4%B8%80%E6%A6%82%E8%A7%88">一、概览</a><ul><li><a href="#collection">Collection</a></li><li><a href="#map">Map</a></li></ul></li><li><a href="#%E4%BA%8C%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">二、容器中的设计模式</a><ul><li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li><li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li></ul></li><li><a href="#%E4%B8%89%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">三、源码分析</a><ul><li><a href="#arraylist">ArrayList</a></li><li><a href="#vector">Vector</a></li><li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a></li><li><a href="#linkedlist">LinkedList</a></li><li><a href="#hashmap">HashMap</a></li><li><a href="#concurrenthashmap">ConcurrentHashMap</a></li><li><a href="#linkedhashmap">LinkedHashMap</a></li><li><a href="#weakhashmap">WeakHashMap</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC --></li></ul></li></ul><h2 id="一、概览">一、概览</h2><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h3 id="Collection">Collection</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png"/> </div><br><h4 id="1-Set">1. Set</h4><ul><li><p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p></li><li><p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p></li><li><p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</p></li></ul><h4 id="2-List">2. List</h4><ul><li><p>ArrayList：基于动态数组实现，支持随机访问。</p></li><li><p>Vector：和 ArrayList 类似，但它是线程安全的。</p></li><li><p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p></li></ul><h4 id="3-Queue">3. Queue</h4><ul><li><p>LinkedList：可以用它来实现双向队列。</p></li><li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p></li></ul><h3 id="Map">Map</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201101234335837.png"/> </div><br><ul><li><p>TreeMap：基于红黑树实现。</p></li><li><p>HashMap：基于哈希表实现。</p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p></li><li><p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></li></ul><h2 id="二、容器中的设计模式">二、容器中的设计模式</h2><h3 id="迭代器模式">迭代器模式</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png"/> </div><br><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">&quot;a&quot;</span>);list.add(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-keyword">for</span> (String item : list) &#123;    System.out.println(item);&#125;</code></pre></div><h3 id="适配器模式">适配器模式</h3><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span></span></code></pre></div><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><div class="hljs code-wrapper"><pre><code class="hljs java">Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;List list = Arrays.asList(arr);</code></pre></div><p>也可以使用以下方式调用 asList()：</p><div class="hljs code-wrapper"><pre><code class="hljs java">List list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre></div><h2 id="三、源码分析">三、源码分析</h2><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p><p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p><h3 id="ArrayList">ArrayList</h3><h4 id="1-概览">1. 概览</h4><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></code></pre></div><p>数组的默认大小为 10。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png"/> </div><br><h4 id="2-扩容">2. 扩容</h4><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    ensureExplicitCapacity(minCapacity);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    modCount++;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre></div><h4 id="3-删除元素">3. 删除元素</h4><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    rangeCheck(index);    modCount++;    E oldValue = elementData(index);    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre></div><h4 id="4-序列化">4. 序列化</h4><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span></code></pre></div><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;    elementData = EMPTY_ELEMENTDATA;    <span class="hljs-comment">// Read in size, and any hidden stuff</span>    s.defaultReadObject();    <span class="hljs-comment">// Read in capacity</span>    s.readInt(); <span class="hljs-comment">// ignored</span>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// be like clone(), allocate array based upon size not capacity</span>        ensureCapacityInternal(size);        Object[] a = elementData;        <span class="hljs-comment">// Read in all elements in the proper order.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;            a[i] = s.readObject();        &#125;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;    <span class="hljs-comment">// Write out element count, and any hidden stuff</span>    <span class="hljs-keyword">int</span> expectedModCount = modCount;    s.defaultWriteObject();    <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span>    s.writeInt(size);    <span class="hljs-comment">// Write out all elements in the proper order.</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;        s.writeObject(elementData[i]);    &#125;    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;</code></pre></div><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file));oos.writeObject(list);</code></pre></div><h4 id="5-Fail-Fast">5. Fail-Fast</h4><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p><h3 id="Vector">Vector</h3><h4 id="1-同步">1. 同步</h4><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    modCount++;    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);    elementData[elementCount++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">if</span> (index &gt;= elementCount)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);    <span class="hljs-keyword">return</span> elementData(index);&#125;</code></pre></div><h4 id="2-扩容-2">2. 扩容</h4><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">int</span> capacityIncrement)</span> </span>&#123;    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];    <span class="hljs-keyword">this</span>.capacityIncrement = capacityIncrement;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?                                     capacityIncrement : oldCapacity);    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre></div><p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);&#125;</code></pre></div><h4 id="3-与-ArrayList-的比较">3. 与 ArrayList 的比较</h4><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li></ul><h4 id="4-替代方案">4. 替代方案</h4><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list);</code></pre></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</code></pre></div><h3 id="CopyOnWriteArrayList">CopyOnWriteArrayList</h3><h4 id="1-读写分离">1. 读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        newElements[len] = e;        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setArray</span><span class="hljs-params">(Object[] a)</span> </span>&#123;    array = a;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> (E) a[index];&#125;</code></pre></div><h4 id="2-适用场景">2. 适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h3 id="LinkedList">LinkedList</h3><h4 id="1-概览-2">1. 概览</h4><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;&#125;</code></pre></div><p>每个链表存储了 first 和 last 指针：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-keyword">transient</span> Node&lt;E&gt; last;</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png"/> </div><br><h4 id="2-与-ArrayList-的比较">2. 与 ArrayList 的比较</h4><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p><ul><li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li><li>链表不支持随机访问，但插入删除只需要改变指针。</li></ul><h3 id="HashMap">HashMap</h3><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p><h4 id="1-存储结构">1. 存储结构</h4><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png"/> </div><br><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Entry[] table;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> K key;    V value;    Entry&lt;K,V&gt; next;    <span class="hljs-keyword">int</span> hash;    Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;        value = v;        next = n;        key = k;        hash = h;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;        V oldValue = value;        value = newValue;        <span class="hljs-keyword">return</span> oldValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        Map.Entry e = (Map.Entry)o;        Object k1 = getKey();        Object k2 = e.getKey();        <span class="hljs-keyword">if</span> (k1 == k2 || (k1 != <span class="hljs-keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;            Object v1 = getValue();            Object v2 = e.getValue();            <span class="hljs-keyword">if</span> (v1 == v2 || (v1 != <span class="hljs-keyword">null</span> &amp;&amp; v1.equals(v2)))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">&quot;=&quot;</span> + getValue();    &#125;&#125;</code></pre></div><h4 id="2-拉链法的工作原理">2. 拉链法的工作原理</h4><div class="hljs code-wrapper"><pre><code class="hljs java">HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-string">&quot;K1&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>);map.put(<span class="hljs-string">&quot;K2&quot;</span>, <span class="hljs-string">&quot;V2&quot;</span>);map.put(<span class="hljs-string">&quot;K3&quot;</span>, <span class="hljs-string">&quot;V3&quot;</span>);</code></pre></div><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li><li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li><li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li></ul><p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208235258643.png"/> </div><br><h4 id="3-put-操作">3. put 操作</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;        inflateTable(threshold);    &#125;    <span class="hljs-comment">// 键为 null 单独处理</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> putForNullKey(value);    <span class="hljs-keyword">int</span> hash = hash(key);    <span class="hljs-comment">// 确定桶下标</span>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);    <span class="hljs-comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;        Object k;        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    modCount++;    <span class="hljs-comment">// 插入新键值对</span>    addEntry(hash, key, value, i);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> V <span class="hljs-title">putForNullKey</span><span class="hljs-params">(V value)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-keyword">null</span>) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    modCount++;    addEntry(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, value, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-keyword">null</span> != table[bucketIndex])) &#123;        resize(<span class="hljs-number">2</span> * table.length);        hash = (<span class="hljs-keyword">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;        bucketIndex = indexFor(hash, table.length);    &#125;    createEntry(hash, key, value, bucketIndex);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    <span class="hljs-comment">// 头插法，链表头部指向新的键值对</span>    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);    size++;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;    value = v;    next = n;    key = k;    hash = h;&#125;</code></pre></div><h4 id="4-确定桶下标">4. 确定桶下标</h4><p>很多操作都需要先确定一个键值对所在的桶下标。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> hash = hash(key);<span class="hljs-keyword">int</span> i = indexFor(hash, table.length);</code></pre></div><p><strong>4.1 计算 hash 值</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;    <span class="hljs-keyword">int</span> h = hashSeed;    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);    &#125;    h ^= k.hashCode();    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</code></pre></div><p><strong>4.2 取模</strong></p><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>   : <span class="hljs-number">00010000</span><span class="hljs-attribute">x</span>-<span class="hljs-number">1</span> : <span class="hljs-number">00001111</span></code></pre></div><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">y</span>       : <span class="hljs-number">10110010</span><span class="hljs-attribute">x</span>-<span class="hljs-number">1</span>     : <span class="hljs-number">00001111</span><span class="hljs-attribute">y</span>&amp;(x-<span class="hljs-number">1</span>) : <span class="hljs-number">00000010</span></code></pre></div><p>这个性质和 y 对 x 取模效果是一样的：</p><div class="hljs code-wrapper"><pre><code class="hljs ada">y   : 10110010x   : 00010000y%x : 00000010</code></pre></div><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);&#125;</code></pre></div><h4 id="5-扩容-基本原理">5. 扩容-基本原理</h4><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">capacity</td><td style="text-align:left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td style="text-align:center">size</td><td style="text-align:left">键值对数量。</td></tr><tr><td style="text-align:center">threshold</td><td style="text-align:left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr><tr><td style="text-align:center">loadFactor</td><td style="text-align:left">装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td></tr></tbody></table><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-keyword">transient</span> Entry[] table;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<span class="hljs-keyword">int</span> threshold;<span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</code></pre></div><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);    <span class="hljs-keyword">if</span> (size++ &gt;= threshold)        resize(<span class="hljs-number">2</span> * table.length);&#125;</code></pre></div><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;    Entry[] oldTable = table;    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;        threshold = Integer.MAX_VALUE;        <span class="hljs-keyword">return</span>;    &#125;    Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];    transfer(newTable);    table = newTable;    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;    Entry[] src = table;    <span class="hljs-keyword">int</span> newCapacity = newTable.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;        Entry&lt;K,V&gt; e = src[j];        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            src[j] = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">do</span> &#123;                Entry&lt;K,V&gt; next = e.next;                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                newTable[i] = e;                e = next;            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);        &#125;    &#125;&#125;</code></pre></div><h4 id="6-扩容-重新计算桶下标">6. 扩容-重新计算桶下标</h4><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><div class="hljs code-wrapper"><pre><code class="hljs html">capacity     : 00010000new capacity : 00100000</code></pre></div><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><ul><li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li><li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li></ul><h4 id="7-计算数组容量">7. 计算数组容量</h4><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p><p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mask</span> |= mask &gt;&gt; <span class="hljs-number">1</span>    <span class="hljs-number">11011000</span><span class="hljs-attribute">mask</span> |= mask &gt;&gt; <span class="hljs-number">2</span>    <span class="hljs-number">11111110</span><span class="hljs-attribute">mask</span> |= mask &gt;&gt; <span class="hljs-number">4</span>    <span class="hljs-number">11111111</span></code></pre></div><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">num</span>     <span class="hljs-number">10010000</span><span class="hljs-attribute">mask</span>+<span class="hljs-number">1</span> <span class="hljs-number">100000000</span></code></pre></div><p>以下是 HashMap 中计算数组容量的代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre></div><h4 id="8-链表转红黑树">8. 链表转红黑树</h4><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p><h4 id="9-与-Hashtable-的比较">9. 与 Hashtable 的比较</h4><ul><li>Hashtable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h3 id="ConcurrentHashMap">ConcurrentHashMap</h3><h4 id="1-存储结构-2">1. 存储结构</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png"/> </div><br><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-keyword">volatile</span> V value;    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;&#125;</code></pre></div><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><p>Segment 继承自 ReentrantLock。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2249069246763182397L</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES =        Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;</code></pre></div><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;</code></pre></div><h4 id="2-size-操作">2. size 操作</h4><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The number of elements. Accessed only either within locks</span><span class="hljs-comment"> * or among other volatile reads that maintain visibility.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;</code></pre></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Number of unsynchronized retries in size and containsValue</span><span class="hljs-comment"> * methods before resorting to locking. This is used to avoid</span><span class="hljs-comment"> * unbounded retries if tables undergo continuous modification</span><span class="hljs-comment"> * which would make it impossible to obtain an accurate result.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span>    <span class="hljs-comment">// continuous async changes in table, resort to locking.</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;    <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span>    <span class="hljs-keyword">long</span> sum;         <span class="hljs-comment">// sum of modCounts</span>    <span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>;   <span class="hljs-comment">// previous sum</span>    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn&#x27;t retry</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 超过尝试次数，则对每个 Segment 加锁</span>            <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)                    ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span>            &#125;            sum = <span class="hljs-number">0L</span>;            size = <span class="hljs-number">0</span>;            overflow = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;                Segment&lt;K,V&gt; seg = segmentAt(segments, j);                <span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;                    sum += seg.modCount;                    <span class="hljs-keyword">int</span> c = seg.count;                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)                        overflow = <span class="hljs-keyword">true</span>;                &#125;            &#125;            <span class="hljs-comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span>            <span class="hljs-keyword">if</span> (sum == last)                <span class="hljs-keyword">break</span>;            last = sum;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)                segmentAt(segments, j).unlock();        &#125;    &#125;    <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;&#125;</code></pre></div><h4 id="3-JDK-1-8-的改动">3. JDK 1.8 的改动</h4><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p><p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p><h3 id="LinkedHashMap">LinkedHashMap</h3><h4 id="存储结构">存储结构</h4><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></code></pre></div><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The head (eldest) of the doubly linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;<span class="hljs-comment">/**</span><span class="hljs-comment"> * The tail (youngest) of the doubly linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</code></pre></div><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accessOrder;</code></pre></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;</code></pre></div><h4 id="afterNodeAccess">afterNodeAccess()</h4><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span>    LinkedHashMap.Entry&lt;K,V&gt; last;    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)            head = a;        <span class="hljs-keyword">else</span>            b.after = a;        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)            a.before = b;        <span class="hljs-keyword">else</span>            last = b;        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)            head = p;        <span class="hljs-keyword">else</span> &#123;            p.before = last;            last.after = p;        &#125;        tail = p;        ++modCount;    &#125;&#125;</code></pre></div><h4 id="afterNodeInsertion">afterNodeInsertion()</h4><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span>    LinkedHashMap.Entry&lt;K,V&gt; first;    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;        K key = first.key;        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><h4 id="LRU-缓存">LRU 缓存</h4><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES  为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ENTRIES = <span class="hljs-number">3</span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span> </span>&#123;        <span class="hljs-keyword">return</span> size() &gt; MAX_ENTRIES;    &#125;    LRUCache() &#123;        <span class="hljs-keyword">super</span>(MAX_ENTRIES, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> LRUCache&lt;&gt;();    cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>);    cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>);    cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);    cache.get(<span class="hljs-number">1</span>);    cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;d&quot;</span>);    System.out.println(cache.keySet());&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html">[3, 1, 4]</code></pre></div><h3 id="WeakHashMap">WeakHashMap</h3><h4 id="存储结构-2">存储结构</h4><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">Object</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></code></pre></div><h4 id="ConcurrentCache">ConcurrentCache</h4><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p><p>ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; eden;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; longterm;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;        <span class="hljs-keyword">this</span>.size = size;        <span class="hljs-keyword">this</span>.eden = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(size);        <span class="hljs-keyword">this</span>.longterm = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;(size);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K k)</span> </span>&#123;        V v = <span class="hljs-keyword">this</span>.eden.get(k);        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;            v = <span class="hljs-keyword">this</span>.longterm.get(k);            <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">this</span>.eden.put(k, v);        &#125;        <span class="hljs-keyword">return</span> v;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K k, V v)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eden.size() &gt;= size) &#123;            <span class="hljs-keyword">this</span>.longterm.putAll(<span class="hljs-keyword">this</span>.eden);            <span class="hljs-keyword">this</span>.eden.clear();        &#125;        <span class="hljs-keyword">this</span>.eden.put(k, v);    &#125;&#125;</code></pre></div><h2 id="参考资料">参考资料</h2><ul><li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href="https://www.w3resource.com/java-tutorial/java-collections.php">Java Collection Framework</a></li><li><a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm">Iterator 模式</a></li><li><a href="https://tech.meituan.com/java_hashmap.html">Java 8 系列之重新认识 HashMap</a></li><li><a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html">What is difference between HashMap and Hashtable in Java?</a></li><li><a href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/">Java 集合之 HashMap</a></li><li><a href="http://www.programering.com/a/MDO3QDNwATM.html">The principle of ConcurrentHashMap analysis</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/">探索 ConcurrentHashMap 高并发性的实现机制</a></li><li><a href="https://www.jianshu.com/p/75adf47958a7">HashMap 相关面试题及其解答</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html">Java 集合细节（二）：asList 的缺陷</a></li><li><a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/">Java Collection Framework – The LinkedList Class</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础</title>
    <link href="/2021/11/18/JAVA%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/11/18/JAVA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>Java 基础</h1><!-- GFM-TOC --><ul><li><a href="#java-%E5%9F%BA%E7%A1%80">Java 基础</a><ul><li><a href="#%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">一、数据类型</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></li><li><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">包装类型</a></li><li><a href="#%E7%BC%93%E5%AD%98%E6%B1%A0">缓存池</a></li></ul></li><li><a href="#%E4%BA%8Cstring">二、String</a><ul><li><a href="#%E6%A6%82%E8%A7%88">概览</a></li><li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84">不可变的好处</a></li><li><a href="#string-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder</a></li><li><a href="#string-pool">String Pool</a></li><li><a href="#new-stringabc">new String(“abc”)</a></li></ul></li><li><a href="#%E4%B8%89%E8%BF%90%E7%AE%97">三、运算</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a></li><li><a href="#float-%E4%B8%8E-double">float 与 double</a></li><li><a href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式类型转换</a></li><li><a href="#switch">switch</a></li></ul></li><li><a href="#%E5%9B%9B%E5%85%B3%E9%94%AE%E5%AD%97">四、关键字</a><ul><li><a href="#final">final</a></li><li><a href="#static">static</a></li></ul></li><li><a href="#%E4%BA%94object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95">五、Object 通用方法</a><ul><li><a href="#%E6%A6%82%E8%A7%88">概览</a></li><li><a href="#equals">equals()</a></li><li><a href="#hashcode">hashCode()</a></li><li><a href="#tostring">toString()</a></li><li><a href="#clone">clone()</a></li></ul></li><li><a href="#%E5%85%AD%E7%BB%A7%E6%89%BF">六、继承</a><ul><li><a href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">抽象类与接口</a></li><li><a href="#super">super</a></li><li><a href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD">重写与重载</a></li></ul></li><li><a href="#%E4%B8%83%E5%8F%8D%E5%B0%84">七、反射</a></li><li><a href="#%E5%85%AB%E5%BC%82%E5%B8%B8">八、异常</a></li><li><a href="#%E4%B9%9D%E6%B3%9B%E5%9E%8B">九、泛型</a></li><li><a href="#%E5%8D%81%E6%B3%A8%E8%A7%A3">十、注解</a></li><li><a href="#%E5%8D%81%E4%B8%80%E7%89%B9%E6%80%A7">十一、特性</a><ul><li><a href="#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">Java 各版本的新特性</a></li><li><a href="#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 与 C++ 的区别</a></li><li><a href="#jre-or-jdk">JRE or JDK</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC --></li></ul></li></ul><h2 id="一、数据类型">一、数据类型</h2><h3 id="基本类型">基本类型</h3><ul><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li><li>boolean/~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">The Java® Virtual Machine Specification</a></li></ul><h3 id="包装类型">包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><div class="hljs code-wrapper"><pre><code class="hljs java">Integer x = <span class="hljs-number">2</span>;     <span class="hljs-comment">// 装箱 调用了 Integer.valueOf(2)</span><span class="hljs-keyword">int</span> y = x;         <span class="hljs-comment">// 拆箱 调用了 X.intValue()</span></code></pre></div><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a></li></ul><h3 id="缓存池">缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);System.out.println(x == y);    <span class="hljs-comment">// false</span>Integer z = Integer.valueOf(<span class="hljs-number">123</span>);Integer k = Integer.valueOf(<span class="hljs-number">123</span>);System.out.println(z == k);   <span class="hljs-comment">// true</span></code></pre></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);&#125;</code></pre></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<span class="hljs-keyword">static</span> &#123;    <span class="hljs-comment">// high value may be configured by property</span>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;    String integerCacheHighPropValue =        sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);    <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);            i = Math.max(i, <span class="hljs-number">127</span>);            <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span>            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;            <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span>        &#125;    &#125;    high = h;    cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> j = low;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)        cache[k] = <span class="hljs-keyword">new</span> Integer(j++);    <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>    <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;&#125;</code></pre></div><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java">Integer m = <span class="hljs-number">123</span>;Integer n = <span class="hljs-number">123</span>;System.out.println(m == n); <span class="hljs-comment">// true</span></code></pre></div><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p><p>[StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</p><p>](<a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123">https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123</a>)</p><h2 id="二、String">二、String</h2><h3 id="概览">概览</h3><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];&#125;</code></pre></div><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value;    <span class="hljs-comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="hljs-doctag">@code</span> value&#125;. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> coder;&#125;</code></pre></div><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h3 id="不可变的好处">不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png"/> </div><br><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?</a></p><h3 id="String-StringBuffer-and-StringBuilder">String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder</a></p><h3 id="String-Pool">String Pool</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。</p><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);System.out.println(s1 == s2);           <span class="hljs-comment">// false</span>String s3 = s1.intern();String s4 = s2.intern();System.out.println(s3 == s4);           <span class="hljs-comment">// true</span></code></pre></div><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><div class="hljs code-wrapper"><pre><code class="hljs java">String s5 = <span class="hljs-string">&quot;bbb&quot;</span>;String s6 = <span class="hljs-string">&quot;bbb&quot;</span>;System.out.println(s5 == s6);  <span class="hljs-comment">// true</span></code></pre></div><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning">StackOverflow : What is String interning?</a></li><li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></li></ul><h3 id="new-String-“abc”">new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewStringTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);    &#125;&#125;</code></pre></div><p>使用 javap -verbose 进行反编译，得到以下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span>Constant pool:<span class="hljs-comment">// ...</span>   #<span class="hljs-number">2</span> = Class              #<span class="hljs-number">18</span>            <span class="hljs-comment">// java/lang/String</span>   #<span class="hljs-number">3</span> = String             #<span class="hljs-number">19</span>            <span class="hljs-comment">// abc</span><span class="hljs-comment">// ...</span>  #<span class="hljs-number">18</span> = Utf8               java/lang/String  #<span class="hljs-number">19</span> = Utf8               abc<span class="hljs-comment">// ...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/String</span>         <span class="hljs-number">3</span>: dup         <span class="hljs-number">4</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String abc</span>         <span class="hljs-number">6</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span>         <span class="hljs-number">9</span>: astore_1<span class="hljs-comment">// ...</span></code></pre></div><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(String original)</span> </span>&#123;    <span class="hljs-keyword">this</span>.value = original.value;    <span class="hljs-keyword">this</span>.hash = original.hash;&#125;</code></pre></div><h2 id="三、运算">三、运算</h2><h3 id="参数传递">参数传递</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;    String name;    Dog(String name) &#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function">String <span class="hljs-title">getObjectAddress</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString();    &#125;&#125;</code></pre></div><p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassByValueExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Dog dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;A&quot;</span>);        func(dog);        System.out.println(dog.getName());          <span class="hljs-comment">// B</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Dog dog)</span> </span>&#123;        dog.setName(<span class="hljs-string">&quot;B&quot;</span>);    &#125;&#125;</code></pre></div><p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassByValueExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Dog dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;A&quot;</span>);        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span>        func(dog);        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span>        System.out.println(dog.getName());          <span class="hljs-comment">// A</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Dog dog)</span> </span>&#123;        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span>        dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;B&quot;</span>);        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@74a14482</span>        System.out.println(dog.getName());          <span class="hljs-comment">// B</span>    &#125;&#125;</code></pre></div><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p><h3 id="float-与-double">float 与 double</h3><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// float f = 1.1;</span></code></pre></div><p>1.1f 字面量才是 float 类型。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">float</span> f = <span class="hljs-number">1.1f</span>;</code></pre></div><h3 id="隐式类型转换">隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">short</span> s1 = <span class="hljs-number">1</span>;<span class="hljs-comment">// s1 = s1 + 1;</span></code></pre></div><p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p><div class="hljs code-wrapper"><pre><code class="hljs java">s1 += <span class="hljs-number">1</span>;s1++;</code></pre></div><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><div class="hljs code-wrapper"><pre><code class="hljs java">s1 = (<span class="hljs-keyword">short</span>) (s1 + <span class="hljs-number">1</span>);</code></pre></div><p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</a></p><h3 id="switch">switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-keyword">switch</span> (s) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:        System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:        System.out.println(<span class="hljs-string">&quot;bbb&quot;</span>);        <span class="hljs-keyword">break</span>;&#125;</code></pre></div><p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// long x = 111;</span><span class="hljs-comment">// switch (x) &#123; // Incompatible types. Found: &#x27;long&#x27;, required: &#x27;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#x27;</span><span class="hljs-comment">//     case 111:</span><span class="hljs-comment">//         System.out.println(111);</span><span class="hljs-comment">//         break;</span><span class="hljs-comment">//     case 222:</span><span class="hljs-comment">//         System.out.println(222);</span><span class="hljs-comment">//         break;</span><span class="hljs-comment">// &#125;</span></code></pre></div><p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can’t your switch statement data type be long, Java?</a></p><h2 id="四、关键字">四、关键字</h2><h3 id="final">final</h3><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<span class="hljs-comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span><span class="hljs-keyword">final</span> A y = <span class="hljs-keyword">new</span> A();y.a = <span class="hljs-number">1</span>;</code></pre></div><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h3 id="static">static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;         <span class="hljs-comment">// 实例变量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;  <span class="hljs-comment">// 静态变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span>        A a = <span class="hljs-keyword">new</span> A();        <span class="hljs-keyword">int</span> x = a.x;        <span class="hljs-keyword">int</span> y = A.y;    &#125;&#125;</code></pre></div><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span>&#125;</code></pre></div><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span> a = x;        <span class="hljs-comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span>        <span class="hljs-comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span>    &#125;&#125;</code></pre></div><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;123&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a1 = <span class="hljs-keyword">new</span> A();        A a2 = <span class="hljs-keyword">new</span> A();    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html">123</code></pre></div><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span>        OuterClass outerClass = <span class="hljs-keyword">new</span> OuterClass();        InnerClass innerClass = outerClass.<span class="hljs-function">new <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>;        StaticInnerClass staticInnerClass = <span class="hljs-keyword">new</span> StaticInnerClass();    &#125;&#125;</code></pre></div><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.ClassName.*</code></pre></div><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String staticField = <span class="hljs-string">&quot;静态变量&quot;</span>;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;    System.out.println(<span class="hljs-string">&quot;静态语句块&quot;</span>);&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String field = <span class="hljs-string">&quot;实例变量&quot;</span>;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">&#123;    System.out.println(<span class="hljs-string">&quot;普通语句块&quot;</span>);&#125;</code></pre></div><p>最后才是构造函数的初始化。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InitialOrderTest</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;构造函数&quot;</span>);&#125;</code></pre></div><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="五、Object-通用方法">五、Object 通用方法</h2><h3 id="概览-2">概览</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; <span class="hljs-title">getClass</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span></code></pre></div><h3 id="equals">equals()</h3><p><strong>1. 等价关系</strong></p><p>两个对象具有等价关系，需要满足以下五个条件：</p><p>Ⅰ 自反性</p><div class="hljs code-wrapper"><pre><code class="hljs java">x.equals(x); <span class="hljs-comment">// true</span></code></pre></div><p>Ⅱ 对称性</p><div class="hljs code-wrapper"><pre><code class="hljs java">x.equals(y) == y.equals(x); <span class="hljs-comment">// true</span></code></pre></div><p>Ⅲ 传递性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))    x.equals(z); <span class="hljs-comment">// true;</span></code></pre></div><p>Ⅳ 一致性</p><p>多次调用 equals() 方法结果不变</p><div class="hljs code-wrapper"><pre><code class="hljs java">x.equals(y) == x.equals(y); <span class="hljs-comment">// true</span></code></pre></div><p>Ⅴ 与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><div class="hljs code-wrapper"><pre><code class="hljs java">x.equals(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// false;</span></code></pre></div><p><strong>2. 等价与相等</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);System.out.println(x.equals(y)); <span class="hljs-comment">// true</span>System.out.println(x == y);      <span class="hljs-comment">// false</span></code></pre></div><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EqualExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EqualExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;        <span class="hljs-keyword">this</span>.z = z;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        EqualExample that = (EqualExample) o;        <span class="hljs-keyword">if</span> (x != that.x) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (y != that.y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> z == that.z;    &#125;&#125;</code></pre></div><h3 id="hashCode">hashCode()</h3><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p><p>HashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java">EqualExample e1 = <span class="hljs-keyword">new</span> EqualExample(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);EqualExample e2 = <span class="hljs-keyword">new</span> EqualExample(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);System.out.println(e1.equals(e2)); <span class="hljs-comment">// true</span>HashSet&lt;EqualExample&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size());   <span class="hljs-comment">// 2</span></code></pre></div><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">17</span>;    result = <span class="hljs-number">31</span> * result + x;    result = <span class="hljs-number">31</span> * result + y;    result = <span class="hljs-number">31</span> * result + z;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h3 id="toString">toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToStringExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = number;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">ToStringExample example = <span class="hljs-keyword">new</span> ToStringExample(<span class="hljs-number">123</span>);System.out.println(example.toString());</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html">ToStringExample@4554617c</code></pre></div><h3 id="clone">clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">CloneExample e1 = <span class="hljs-keyword">new</span> CloneExample();<span class="hljs-comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></code></pre></div><p>重写 clone() 得到以下实现：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="hljs-keyword">return</span> (CloneExample)<span class="hljs-keyword">super</span>.clone();    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">CloneExample e1 = <span class="hljs-keyword">new</span> CloneExample();<span class="hljs-keyword">try</span> &#123;    CloneExample e2 = e1.clone();&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;    e.printStackTrace();&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html">java.lang.CloneNotSupportedException: CloneExample</code></pre></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();    &#125;&#125;</code></pre></div><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShallowCloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShallowCloneExample</span><span class="hljs-params">()</span> </span>&#123;        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            arr[i] = i;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        arr[index] = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> arr[index];    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ShallowCloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="hljs-keyword">return</span> (ShallowCloneExample) <span class="hljs-keyword">super</span>.clone();    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">ShallowCloneExample e1 = <span class="hljs-keyword">new</span> ShallowCloneExample();ShallowCloneExample e2 = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    e2 = e1.clone();&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;    e.printStackTrace();&#125;e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 222</span></code></pre></div><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeepCloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeepCloneExample</span><span class="hljs-params">()</span> </span>&#123;        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            arr[i] = i;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        arr[index] = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> arr[index];    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> DeepCloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        DeepCloneExample result = (DeepCloneExample) <span class="hljs-keyword">super</span>.clone();        result.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            result.arr[i] = arr[i];        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">DeepCloneExample e1 = <span class="hljs-keyword">new</span> DeepCloneExample();DeepCloneExample e2 = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    e2 = e1.clone();&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;    e.printStackTrace();&#125;e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span></code></pre></div><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneConstructorExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloneConstructorExample</span><span class="hljs-params">()</span> </span>&#123;        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            arr[i] = i;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> </span>&#123;        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[original.arr.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;            arr[i] = original.arr[i];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        arr[index] = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> arr[index];    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">CloneConstructorExample e1 = <span class="hljs-keyword">new</span> CloneConstructorExample();CloneConstructorExample e2 = <span class="hljs-keyword">new</span> CloneConstructorExample(e1);e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span></code></pre></div><h2 id="六、继承">六、继承</h2><h3 id="访问权限">访问权限</h3><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessExample</span> </span>&#123;    <span class="hljs-keyword">public</span> String id;&#125;</code></pre></div><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = Integer.valueOf(id);    &#125;&#125;</code></pre></div><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessWithInnerClassExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;        <span class="hljs-keyword">int</span> x;    &#125;    <span class="hljs-keyword">private</span> InnerClass innerClass;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccessWithInnerClassExample</span><span class="hljs-params">()</span> </span>&#123;        innerClass = <span class="hljs-keyword">new</span> InnerClass();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> innerClass.x;  <span class="hljs-comment">// 直接访问</span>    &#125;&#125;</code></pre></div><h3 id="抽象类与接口">抽象类与接口</h3><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClassExample</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExtendClassExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClassExample</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;func1&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span>AbstractClassExample ac2 = <span class="hljs-keyword">new</span> AbstractExtendClassExample();ac2.func1();</code></pre></div><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</p><p>接口的字段默认都是 static 和 final 的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);    &#125;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">123</span>;    <span class="hljs-comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span>    <span class="hljs-comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span>    <span class="hljs-comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span>    <span class="hljs-comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span>&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceImplementExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InterfaceExample</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;func1&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span>InterfaceExample ie2 = <span class="hljs-keyword">new</span> InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x);</code></pre></div><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">Abstract Methods and Classes</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li><li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li><li><a href="https://www.journaldev.com/12850/java-9-private-methods-interfaces">Java 9 Private Methods in Interfaces</a></li></ul><h3 id="super">super</h3><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperExample</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SuperExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;SuperExample.func()&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperExtendExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SuperExtendExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;        <span class="hljs-keyword">super</span>(x, y);        <span class="hljs-keyword">this</span>.z = z;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.func();        System.out.println(<span class="hljs-string">&quot;SuperExtendExample.func()&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">SuperExample e = <span class="hljs-keyword">new</span> SuperExtendExample(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);e.func();</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html">SuperExample.func()SuperExtendExample.func()</code></pre></div><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html">Using the Keyword super</a></p><h3 id="重写与重载">重写与重载</h3><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList&lt;Integer&gt;，是父类返回类型 List&lt;Integer&gt; 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Integer&gt; <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    &#125;&#125;</code></pre></div><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">    A</span><span class="hljs-comment">    |</span><span class="hljs-comment">    B</span><span class="hljs-comment">    |</span><span class="hljs-comment">    C</span><span class="hljs-comment">    |</span><span class="hljs-comment">    D</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(A obj)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;A.show(A)&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(C obj)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;A.show(C)&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(A obj)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B.show(A)&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> </span>&#123;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    A a = <span class="hljs-keyword">new</span> A();    B b = <span class="hljs-keyword">new</span> B();    C c = <span class="hljs-keyword">new</span> C();    D d = <span class="hljs-keyword">new</span> D();    <span class="hljs-comment">// 在 A 中存在 show(A obj)，直接调用</span>    a.show(a); <span class="hljs-comment">// A.show(A)</span>    <span class="hljs-comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span>    a.show(b); <span class="hljs-comment">// A.show(A)</span>    <span class="hljs-comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span>    b.show(c); <span class="hljs-comment">// A.show(C)</span>    <span class="hljs-comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span>    b.show(d); <span class="hljs-comment">// A.show(C)</span>    <span class="hljs-comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span>    A ba = <span class="hljs-keyword">new</span> B();    ba.show(c); <span class="hljs-comment">// A.show(C)</span>    ba.show(d); <span class="hljs-comment">// A.show(C)</span>&#125;</code></pre></div><p><strong>2. 重载（Overload）</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverloadingExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        System.out.println(x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, String y)</span> </span>&#123;        System.out.println(x + <span class="hljs-string">&quot; &quot;</span> + y);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    OverloadingExample example = <span class="hljs-keyword">new</span> OverloadingExample();    example.show(<span class="hljs-number">1</span>);    example.show(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>);&#125;</code></pre></div><h2 id="七、反射">七、反射</h2><p>每个类都有一个   <strong>Class</strong>   对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><strong>Field</strong>  ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong>  ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong>  ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><p><strong>反射的优点：</strong></p><ul><li><strong>可扩展性</strong>   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><strong>类浏览器和可视化开发环境</strong>   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><strong>调试器和测试工具</strong>   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><strong>反射的缺点：</strong></p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><p><strong>性能开销</strong>   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p></li><li><p><strong>安全限制</strong>   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p></li><li><p><strong>内部暴露</strong>   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p></li><li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></p></li><li><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></p></li></ul><h2 id="八、异常">八、异常</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：  <strong>Error</strong>   和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><strong>受检异常</strong>  ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong>  ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png" width="600"/> </div><br><ul><li><p><a href="https://www.journaldev.com/2167/java-exception-interview-questions-and-answersl">Java Exception Interview Questions and Answers</a></p></li><li><p><a href="https://www.cnblogs.com/Qian123/p/5715402.html">Java提高篇——Java 异常处理</a></p></li></ul><h2 id="九、泛型">九、泛型</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// T stands for &quot;Type&quot;</span>    <span class="hljs-keyword">private</span> T t;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T t)</span> </span>&#123; <span class="hljs-keyword">this</span>.t = t; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;&#125;</code></pre></div><ul><li><a href="https://www.cnblogs.com/Blue-Keroro/p/8875898.html">Java 泛型详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></li></ul><h2 id="十、注解">十、注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p><h2 id="十一、特性">十一、特性</h2><h3 id="Java-各版本的新特性">Java 各版本的新特性</h3><p><strong>New highlights in Java SE 8</strong></p><ol><li>Lambda Expressions</li><li>Pipelines and Streams</li><li>Date and Time API</li><li>Default Methods</li><li>Type Annotations</li><li>Nashhorn JavaScript Engine</li><li>Concurrent Accumulators</li><li>Parallel operations</li><li>PermGen Error Removed</li></ol><p><strong>New highlights in Java SE 7</strong></p><ol><li>Strings in Switch Statement</li><li>Type Inference for Generic Instance Creation</li><li>Multiple Exception Handling</li><li>Support for Dynamic Languages</li><li>Try with Resources</li><li>Java nio Package</li><li>Binary Literals, Underscore in literals</li><li>Diamond Syntax</li></ol><ul><li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li><li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li></ul><h3 id="Java-与-C-的区别">Java 与 C++ 的区别</h3><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li></ul><p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php">What are the main differences between Java and C++?</a></p><h3 id="JRE-or-JDK">JRE or JDK</h3><ul><li>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li><li>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li></ul><h2 id="参考资料">参考资料</h2><ul><li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>局域网访问win11的Linux子系统</title>
    <link href="/2021/11/18/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AEwin11%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/11/18/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AEwin11%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1>局域网访问win11的Linux子系统</h1><p>1、先找到Linux子系统的ip</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">ip <span class="hljs-keyword">addr </span><span class="hljs-keyword">show </span>eth0</code></pre></div><p>2、设置端口转发（需要管理员权限运行powershell）</p><p>格式</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-builtin-name">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=【宿主机windows平台监听端口】 <span class="hljs-attribute">listenaddress</span>=0.0.0.0 <span class="hljs-attribute">connectport</span>=【wsl2平台监听端口】 <span class="hljs-attribute">connectaddress</span>=【wsl2平台ip】protocol=tcp</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-builtin-name">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=80 <span class="hljs-attribute">listenaddress</span>=0.0.0.0 <span class="hljs-attribute">connectport</span>=80 <span class="hljs-attribute">connectaddress</span>=172.30.144.91 <span class="hljs-attribute">protocol</span>=tcp</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-builtin-name">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=80 <span class="hljs-attribute">listenaddress</span>=* <span class="hljs-attribute">connectport</span>=80 <span class="hljs-attribute">connectaddress</span>=172.30.144.91 <span class="hljs-attribute">protocol</span>=tcp</code></pre></div><p>然后查看下端口转发状态：</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">netsh <span class="hljs-keyword">interface</span> <span class="hljs-symbol">portproxy</span> <span class="hljs-symbol">show</span> <span class="hljs-symbol">all</span></code></pre></div><p>3、删除端口转发</p><p>格式</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy delete v4tov4 <span class="hljs-attribute">listenport</span>=【宿主机windows平台监听端口】 <span class="hljs-attribute">listenaddress</span>=0.0.0.0</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs angelscript">netsh <span class="hljs-keyword">interface</span> <span class="hljs-symbol">portproxy</span> <span class="hljs-symbol">delete</span> <span class="hljs-symbol">v4tov4</span> <span class="hljs-symbol">listenport</span>=<span class="hljs-symbol">80</span> <span class="hljs-symbol">listenaddress</span>=*</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy delete v4tov4 <span class="hljs-attribute">listenport</span>=80 <span class="hljs-attribute">listenaddress</span>=0.0.0.0</code></pre></div><p>注意</p><p>写的是0.0.0.0删的时候也需要是0.0.0.0进行对应，不然会提示找不到文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
